<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Wegovy - AI Assistant</title>
    <link rel="icon" href="favicon.ico">

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@12.0.0/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>

    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="canvas">
        <div class="blank-rectangle" aria-label="Chat rectangle">
            <div class="top-controls">
                <button id="newConversationBtn" class="new-chat-btn" type="button" aria-label="Start a new chat" title="New conversation">
                    <span class="new-chat-label">New</span>
                    <span class="new-chat-plus" aria-hidden="true">+</span>
                </button>
            </div>
            <img src="wegovy_hd.png" alt="Wegovy" class="logo">
            <img src="top.png" alt="" class="top-band" aria-hidden="true">

            <div class="chat-shell">
                <div class="loading-overlay" id="loadingOverlay">
                    <img src="wegovy_hd.png" alt="Wegovy" class="loading-logo">
                    <div class="loading-line" aria-hidden="true"></div>
                    <div class="loading-text" id="loadingText">Connecting to Wegovy...</div>
                </div>

                <div class="chat-messages" id="chatMessages"></div>

                <div class="typing-indicator" id="typingIndicator">
                    <div class="typing-dots">
                        <span class="typing-dot"></span>
                        <span class="typing-dot"></span>
                        <span class="typing-dot"></span>
                    </div>
                </div>

                <div class="error-message" id="errorMessage"></div>

                <div class="chat-input-area">
                    <div class="input-wrapper">
                        <button id="cancelRecordingBtn" class="recording-cancel" type="button" aria-label="Cancel recording" title="Cancel recording">
                            <svg viewBox="0 0 24 24" aria-hidden="true">
                                <path d="M6 6l12 12M18 6l-12 12"/>
                            </svg>
                        </button>
                        <textarea
                            id="chatInput"
                            class="chat-input"
                            placeholder="Type your message..."
                            rows="1"
                        ></textarea>
                        <div class="recording-indicator" id="recordingIndicator" aria-hidden="true">
                            <span class="recording-dot"></span>
                            <span class="recording-label" id="recordingLabel">Recording</span>
                            <span class="recording-waveform" id="recordingWaveform" aria-hidden="true"></span>
                            <span class="recording-timer" id="recordingTimer">0:00</span>
                        </div>
                        <button id="sendButton" class="send-button mode-record" aria-label="Record voice message" title="Record">
                            <span class="icon icon-send" aria-hidden="true">
                                <svg viewBox="0 0 24 24">
                                    <path d="M12 19V7M6 13l6-6 6 6"/>
                                </svg>
                            </span>
                            <span class="icon icon-mic" aria-hidden="true">
                                <svg viewBox="0 0 24 24">
                                    <path d="M12 14a3 3 0 0 0 3-3V6a3 3 0 0 0-6 0v5a3 3 0 0 0 3 3zM19 11a7 7 0 0 1-14 0M12 18v3M8 21h8"/>
                                </svg>
                            </span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            API_BASE: 'https://mojeebapi.azurewebsites.net/api',
            WIDGET_ID: '58686180-0367-4fff-8d01-18ae10f7d70b',
            SUPABASE_URL: 'https://zssyyktaqahdfmehkdxn.supabase.co',
            SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpzc3l5a3RhcWFoZGZtZWhrZHhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM2MjUyNjYsImV4cCI6MjA2OTIwMTI2Nn0.6loB-m_y5To_zk3Inb7wvXSC00OOZ3FhMMTJMfdGlfg'
        };

        const state = {
            conversationId: null,
            agentId: null,
            guestId: null,
            supabaseClient: null,
            messageChannel: null,
            typingChannel: null,
            renderedMessageIds: new Set(),
            isSending: false,
            isRecording: false,
            mediaRecorder: null,
            recordingChunks: [],
            recordingStream: null,
            recordingPlaceholder: '',
            recordingStartedAt: 0,
            recordingTimerId: null,
            recordingDurationSec: 0,
            audioContext: null,
            analyser: null,
            waveformFrameId: null,
            waveformBars: null,
            waveformHeights: null,
            recordingCancelled: false,
            pendingVoiceNotes: new Map()
        };

        const elements = {
            chatMessages: document.getElementById('chatMessages'),
            chatInput: document.getElementById('chatInput'),
            sendButton: document.getElementById('sendButton'),
            cancelRecordingBtn: document.getElementById('cancelRecordingBtn'),
            recordingIndicator: document.getElementById('recordingIndicator'),
            recordingTimer: document.getElementById('recordingTimer'),
            recordingLabel: document.getElementById('recordingLabel'),
            recordingWaveform: document.getElementById('recordingWaveform'),
            typingIndicator: document.getElementById('typingIndicator'),
            errorMessage: document.getElementById('errorMessage'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            loadingText: document.getElementById('loadingText'),
            newConversationBtn: document.getElementById('newConversationBtn')
        };

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function getOrCreateGuestId() {
            let guestId = localStorage.getItem('mojeeb_guest_id');
            if (!guestId) {
                guestId = generateUUID();
                localStorage.setItem('mojeeb_guest_id', guestId);
            }
            return guestId;
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', {
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
        }

        function scrollToBottom() {
            setTimeout(() => {
                elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
            }, 100);
        }

        function showError(message) {
            elements.errorMessage.textContent = message;
            elements.errorMessage.classList.add('active');
            setTimeout(() => {
                elements.errorMessage.classList.remove('active');
            }, 5000);
        }

        function showLoading(text) {
            if (text) {
                elements.loadingText.textContent = text;
            }
            elements.loadingOverlay.classList.remove('hidden');
        }

        function hideLoading() {
            elements.loadingOverlay.classList.add('hidden');
        }

        function sanitizeAndParse(text) {
            try {
                const parsed = marked.parse(text);
                return DOMPurify.sanitize(parsed);
            } catch (error) {
                console.error('Error parsing markdown:', error);
                return DOMPurify.sanitize(text.replace(/</g, '&lt;').replace(/>/g, '&gt;'));
            }
        }

        function parseAttachments(raw) {
            if (!raw) {
                return null;
            }
            if (typeof raw === 'string') {
                try {
                    return JSON.parse(raw);
                } catch (error) {
                    console.warn('Failed to parse attachments:', error);
                    return null;
                }
            }
            if (typeof raw === 'object') {
                return raw;
            }
            return null;
        }

        function hasAudioAttachments(attachments) {
            return Boolean(attachments && Array.isArray(attachments.audio) && attachments.audio.length > 0);
        }

        function formatAudioTime(seconds) {
            if (!Number.isFinite(seconds)) {
                return '0:00';
            }
            const totalSeconds = Math.max(0, Math.floor(seconds));
            const minutes = Math.floor(totalSeconds / 60);
            const remainder = totalSeconds % 60;
            return `${minutes}:${remainder.toString().padStart(2, '0')}`;
        }

        function pauseAllAudio(except) {
            const audios = document.querySelectorAll('audio[data-voice]');
            audios.forEach(audio => {
                if (audio !== except) {
                    audio.pause();
                }
            });
        }

        function buildWaveformBars(count) {
            const heights = [];
            for (let i = 0; i < count; i += 1) {
                const value = Math.abs(Math.sin(i * 0.6)) * 0.75 + 0.2;
                heights.push(Math.round(value * 100));
            }
            return heights;
        }

        function createAudioMessage(attachment, options = {}) {
            const wrapper = document.createElement('div');
            wrapper.className = 'audio-message';
            const isLoading = Boolean(attachment && attachment.loading);
            const isFailed = Boolean(attachment && attachment.failed);
            const hasUrl = Boolean(attachment && attachment.url);

            const playButton = document.createElement('button');
            playButton.className = 'audio-play';
            playButton.type = 'button';
            playButton.setAttribute('aria-label', 'Play voice note');
            playButton.disabled = isLoading || isFailed || !hasUrl;
            playButton.innerHTML = `
                <span class="audio-icon audio-icon-play">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M8 5l11 7-11 7z"/>
                    </svg>
                </span>
                <span class="audio-icon audio-icon-pause">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M7 5h4v14H7zM13 5h4v14h-4z"/>
                    </svg>
                </span>
                <span class="audio-icon audio-icon-loading" aria-hidden="true"></span>
            `;

            const waveform = document.createElement('div');
            waveform.className = 'audio-waveform';
            const barHeights = buildWaveformBars(30);
            barHeights.forEach(height => {
                const bar = document.createElement('span');
                bar.className = 'audio-bar';
                bar.style.height = `${height}%`;
                waveform.appendChild(bar);
            });

            const timeLabel = document.createElement('div');
            timeLabel.className = 'audio-time';
            if (isFailed) {
                timeLabel.textContent = 'Upload failed';
            } else {
                timeLabel.textContent = 'loading';
                timeLabel.classList.add('loading');
            }

            let audio = null;
            if (hasUrl) {
                audio = document.createElement('audio');
                audio.dataset.voice = 'true';
                audio.preload = 'metadata';
                audio.src = attachment.url;
            }

            let duration = attachment?.duration || 0;

            const updateProgress = () => {
                if (!duration) {
                    return;
                }
                const progress = Math.min(1, audio.currentTime / duration);
                const activeCount = Math.round(progress * barHeights.length);
                const bars = waveform.querySelectorAll('.audio-bar');
                bars.forEach((bar, index) => {
                    bar.classList.toggle('active', index < activeCount);
                });
                timeLabel.textContent = `${formatAudioTime(audio.currentTime)} / ${formatAudioTime(duration)}`;
            };

            if (audio) {
                playButton.classList.add('loading');
                audio.addEventListener('loadedmetadata', () => {
                    duration = audio.duration || attachment.duration || 0;
                    timeLabel.classList.add('fading');
                    setTimeout(() => {
                        timeLabel.textContent = `0:00 / ${formatAudioTime(duration)}`;
                        timeLabel.classList.remove('loading');
                        timeLabel.classList.remove('fading');
                        playButton.classList.remove('loading');
                    }, 180);
                });

                audio.addEventListener('timeupdate', updateProgress);
                audio.addEventListener('ended', () => {
                    playButton.classList.remove('playing');
                    playButton.setAttribute('aria-label', 'Play voice note');
                    audio.currentTime = 0;
                    updateProgress();
                });
            }

            playButton.addEventListener('click', () => {
                if (!audio || playButton.disabled) {
                    return;
                }
                if (audio.paused) {
                    pauseAllAudio(audio);
                    audio.play();
                    playButton.classList.add('playing');
                    playButton.setAttribute('aria-label', 'Pause voice note');
                } else {
                    audio.pause();
                    playButton.classList.remove('playing');
                    playButton.setAttribute('aria-label', 'Play voice note');
                }
            });

            waveform.addEventListener('click', (event) => {
                if (!audio || !duration) {
                    return;
                }
                const rect = waveform.getBoundingClientRect();
                const percent = Math.min(1, Math.max(0, (event.clientX - rect.left) / rect.width));
                audio.currentTime = percent * duration;
                updateProgress();
            });

            if (isLoading) {
                playButton.classList.add('loading');
                timeLabel.textContent = 'loading';
            }

            if (isFailed) {
                playButton.classList.remove('loading');
                wrapper.classList.add('failed');
                timeLabel.textContent = 'Upload failed';
                const retry = document.createElement('button');
                retry.type = 'button';
                retry.className = 'audio-retry';
                retry.textContent = 'Retry';
                retry.addEventListener('click', () => {
                    if (typeof options.onRetry === 'function') {
                        options.onRetry();
                    }
                });
                wrapper.appendChild(retry);
            }

            wrapper.appendChild(playButton);
            wrapper.appendChild(waveform);
            wrapper.appendChild(timeLabel);
            if (audio) {
                wrapper.appendChild(audio);
            }
            return wrapper;
        }

        function buildMessageBubble(content, type, attachments, options = {}) {
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';

            const parsedAttachments = parseAttachments(attachments);
            if (hasAudioAttachments(parsedAttachments)) {
                if (content && content.trim().length > 0) {
                    const text = document.createElement('p');
                    text.textContent = content;
                    bubble.appendChild(text);
                }

                parsedAttachments.audio.forEach(attachment => {
                    if (attachment) {
                        bubble.appendChild(createAudioMessage(attachment, options));
                    }
                });
                return bubble;
            }

            if (type === 'assistant') {
                bubble.innerHTML = sanitizeAndParse(content);
            } else {
                bubble.textContent = content;
            }
            return bubble;
        }

        function appendMessage(content, type, messageId, isOptimistic = false, timestamp = null, attachments = null, options = {}) {
            if (messageId && state.renderedMessageIds.has(messageId)) {
                return;
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.dataset.messageId = messageId || `temp-${Date.now()}`;

            if (isOptimistic) {
                messageDiv.dataset.optimistic = 'true';
            }

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'message-content';

            const bubble = buildMessageBubble(content, type, attachments, options);

            const metaRow = document.createElement('div');
            metaRow.className = 'message-meta';

            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            timeDiv.textContent = timestamp ? formatTime(timestamp) : formatTime(new Date());

            const copyButton = document.createElement('button');
            copyButton.className = 'copy-button';
            copyButton.type = 'button';
            copyButton.setAttribute('aria-label', 'Copy message');
            copyButton.title = 'Copy';
            copyButton.innerHTML = `
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M9 9h10v10H9zM5 5h10v10H5z"/>
                </svg>
            `;

            const copyText = type === 'assistant'
                ? (() => {
                    const temp = document.createElement('div');
                    temp.innerHTML = sanitizeAndParse(content);
                    return temp.textContent || '';
                })()
                : content;

            copyButton.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(copyText);
                    copyButton.classList.add('copied');
                    copyButton.innerHTML = `
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M5 13l4 4L19 7"/>
                        </svg>
                    `;
                    setTimeout(() => {
                        copyButton.classList.remove('copied');
                        copyButton.innerHTML = `
                            <svg viewBox="0 0 24 24" aria-hidden="true">
                                <path d="M9 9h10v10H9zM5 5h10v10H5z"/>
                            </svg>
                        `;
                    }, 1200);
                } catch (error) {
                    console.error('Copy failed:', error);
                }
            });

            metaRow.appendChild(timeDiv);
            metaRow.appendChild(copyButton);

            contentWrapper.appendChild(bubble);
            contentWrapper.appendChild(metaRow);

            messageDiv.appendChild(contentWrapper);
            elements.chatMessages.appendChild(messageDiv);
            elements.chatMessages.appendChild(elements.typingIndicator);

            if (messageId) {
                state.renderedMessageIds.add(messageId);
            }

            scrollToBottom();
            updateNewChatVisibility();
        }

        function replaceOptimisticMessage(serverMessage) {
            const optimisticMessages = elements.chatMessages.querySelectorAll('[data-optimistic="true"]');
            const attachments = parseAttachments(serverMessage.attachments);

            if (hasAudioAttachments(attachments)) {
                const optimisticAudio = elements.chatMessages.querySelector('[data-optimistic-audio="true"]');
                if (optimisticAudio) {
                    const tempId = optimisticAudio.dataset.messageId;
                    optimisticAudio.dataset.messageId = serverMessage.id;
                    delete optimisticAudio.dataset.optimistic;
                    delete optimisticAudio.dataset.optimisticAudio;
                    if (tempId) {
                        state.pendingVoiceNotes.delete(tempId);
                    }

                    const bubble = optimisticAudio.querySelector('.message-bubble');
                    if (bubble) {
                        const newBubble = buildMessageBubble(serverMessage.message || '', 'user', attachments);
                        bubble.replaceWith(newBubble);
                    }

                    const timeDiv = optimisticAudio.querySelector('.message-time');
                    if (timeDiv) {
                        timeDiv.textContent = formatTime(serverMessage.created_at);
                    }

                    return true;
                }
            }

            for (const msg of optimisticMessages) {
                const bubble = msg.querySelector('.message-bubble');
                if (bubble && bubble.textContent === serverMessage.message) {
                    msg.dataset.messageId = serverMessage.id;
                    delete msg.dataset.optimistic;

                    const timeDiv = msg.querySelector('.message-time');
                    if (timeDiv) {
                        timeDiv.textContent = formatTime(serverMessage.created_at);
                    }

                    return true;
                }
            }

            return false;
        }

        function showTypingIndicator() {
            elements.chatMessages.appendChild(elements.typingIndicator);
            elements.typingIndicator.classList.add('active');
            scrollToBottom();
        }

        function hideTypingIndicator() {
            elements.typingIndicator.classList.remove('active');
        }

        function updateNewChatVisibility() {
            const messageCount = elements.chatMessages.querySelectorAll('.message').length;
            elements.newConversationBtn.classList.toggle('visible', messageCount > 2);
        }

        async function startNewConversation() {
            try {
                elements.newConversationBtn.disabled = true;
                showLoading('Starting new conversation...');

                localStorage.removeItem('mojeeb_conversation_id');
                state.conversationId = null;

                state.renderedMessageIds.clear();

                elements.chatMessages.innerHTML = '';
                hideTypingIndicator();
                updateNewChatVisibility();

                if (state.typingChannel) {
                    await state.typingChannel.unsubscribe();
                    state.typingChannel = null;
                }

                if (state.messageChannel) {
                    await state.messageChannel.unsubscribe();
                    state.messageChannel = null;
                }

                await initiateConversation();
                subscribeToMessages();
                subscribeToTypingIndicator();

                appendMessage(
                    "Hi, I'm your Wegovy AI assistant. How can I help you today?",
                    'assistant',
                    'welcome-' + Date.now(),
                    false,
                    null,
                    null
                );

                hideLoading();
                elements.newConversationBtn.disabled = false;
                elements.chatInput.focus();
            } catch (error) {
                console.error('Error starting new conversation:', error);
                showError('Failed to start new conversation. Please try again.');
                elements.newConversationBtn.disabled = false;
                hideLoading();
            }
        }

        async function initiateConversation() {
            const guestId = getOrCreateGuestId();

            const savedConversationId = localStorage.getItem('mojeeb_conversation_id');
            const savedAgentId = localStorage.getItem('mojeeb_agent_id');

            if (savedConversationId && savedAgentId) {
                state.conversationId = savedConversationId;
                state.agentId = savedAgentId;
                state.guestId = guestId;
                return { conversationId: savedConversationId, agentId: savedAgentId };
            }

            const response = await fetch(`${CONFIG.API_BASE}/conversations/initiate-widget-conversation`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    widget_id: CONFIG.WIDGET_ID,
                    customer_name: 'Guest User',
                    customer_id: guestId,
                    customer_metadata: {
                        currentUrl: window.location.href,
                        deviceType: /mobile/i.test(navigator.userAgent) ? 'mobile' : 'desktop',
                        language: navigator.language,
                        referrer: document.referrer || 'direct'
                    }
                })
            });

            if (!response.ok) {
                throw new Error('Failed to create conversation');
            }

            const data = await response.json();

            state.conversationId = data.id;
            state.agentId = data.agent_id;
            state.guestId = guestId;

            localStorage.setItem('mojeeb_conversation_id', data.id);
            localStorage.setItem('mojeeb_agent_id', data.agent_id);

            return data;
        }

        async function sendMessage(message) {
            if (state.isSending || !message.trim()) return;

            state.isSending = true;
            elements.sendButton.disabled = true;

            try {
                const tempId = `temp-${Date.now()}`;
                appendMessage(message, 'user', tempId, true);

                elements.chatInput.value = '';
                elements.chatInput.style.height = 'auto';
                updateComposerMode();

                const response = await fetch(`${CONFIG.API_BASE}/chat/generate-response`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        agentId: state.agentId,
                        conversationId: state.conversationId,
                        message: message,
                        messageType: 0,
                        senderId: state.guestId,
                        senderRole: 1
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to send message');
                }
            } catch (error) {
                console.error('Error sending message:', error);
                showError('Failed to send message. Please try again.');

                const optimisticMsg = elements.chatMessages.querySelector(`[data-message-id="${tempId}"]`);
                if (optimisticMsg) {
                    optimisticMsg.remove();
                }
            } finally {
                state.isSending = false;
                elements.sendButton.disabled = false;
                elements.chatInput.focus();
            }
        }

        function initializeSupabase() {
            if (!window.supabase) {
                throw new Error('Supabase client not loaded');
            }

            state.supabaseClient = window.supabase.createClient(
                CONFIG.SUPABASE_URL,
                CONFIG.SUPABASE_ANON_KEY
            );
        }

        function subscribeToMessages() {
            if (!state.supabaseClient || !state.conversationId) return;

            state.messageChannel = state.supabaseClient
                .channel('public:chats')
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'chats',
                    filter: `conversation_id=eq.${state.conversationId}`
                }, (payload) => {
                    const message = payload.new;

                    if (replaceOptimisticMessage(message)) {
                        return;
                    }

                    if (message.sender_id !== state.guestId) {
                        hideTypingIndicator();
                        appendMessage(
                            message.message,
                            'assistant',
                            message.id,
                            false,
                            message.created_at,
                            message.attachments
                        );
                    }
                })
                .subscribe();
        }

        function subscribeToTypingIndicator() {
            if (!state.supabaseClient || !state.conversationId) return;

            state.typingChannel = state.supabaseClient
                .channel(`chat:${state.conversationId}`)
                .on('broadcast', { event: 'typing' }, (payload) => {
                    if (payload.payload?.is_typing) {
                        showTypingIndicator();
                    } else {
                        hideTypingIndicator();
                    }
                })
                .subscribe();
        }

        async function fetchHistoricalMessages() {
            if (!state.supabaseClient || !state.conversationId) return;

            try {
                const { data, error } = await state.supabaseClient
                    .from('chats')
                    .select('*')
                    .eq('conversation_id', state.conversationId)
                    .order('created_at', { ascending: true });

                if (error) throw error;

                if (data && data.length > 0) {
                    data.forEach(message => {
                        appendMessage(
                            message.message,
                            message.sender_id === state.guestId ? 'user' : 'assistant',
                            message.id,
                            false,
                            message.created_at,
                            message.attachments
                        );
                    });
                } else {
                    updateNewChatVisibility();
                }
            } catch (error) {
                console.error('Error fetching messages:', error);
            }
        }

        function setSendButtonMode(mode) {
            elements.sendButton.classList.remove('mode-send', 'mode-record', 'recording');

            if (mode === 'send') {
                elements.sendButton.classList.add('mode-send');
                elements.sendButton.setAttribute('aria-label', 'Send message');
                elements.sendButton.title = 'Send';
                return;
            }

            elements.sendButton.classList.add('mode-record');
            elements.sendButton.setAttribute('aria-label', 'Record voice message');
            elements.sendButton.title = 'Record';
        }

        function updateComposerMode() {
            if (state.isRecording) {
                setSendButtonMode('send');
                elements.sendButton.classList.add('recording');
                return;
            }

            const hasText = elements.chatInput.value.trim().length > 0;
            setSendButtonMode(hasText ? 'send' : 'record');
        }

        function getRecordingMimeType() {
            if (MediaRecorder.isTypeSupported('audio/mp4')) {
                return 'audio/mp4';
            }
            if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
                return 'audio/ogg;codecs=opus';
            }
            if (MediaRecorder.isTypeSupported('audio/aac')) {
                return 'audio/aac';
            }
            if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                return 'audio/webm;codecs=opus';
            }
            return '';
        }

        function formatRecordingDuration(durationMs) {
            const totalSeconds = Math.floor(durationMs / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function setupWaveform(stream) {
            if (!elements.recordingWaveform) {
                return;
            }

            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            if (!AudioContextClass) {
                return;
            }

            state.audioContext = new AudioContextClass();
            if (state.audioContext.state === 'suspended') {
                state.audioContext.resume();
            }
            const source = state.audioContext.createMediaStreamSource(stream);
            state.analyser = state.audioContext.createAnalyser();
            state.analyser.fftSize = 256;
            state.analyser.smoothingTimeConstant = 0.85;
            state.analyser.minDecibels = -90;
            state.analyser.maxDecibels = -10;

            const gainNode = state.audioContext.createGain();
            gainNode.gain.value = 0;
            source.connect(state.analyser);
            state.analyser.connect(gainNode);
            gainNode.connect(state.audioContext.destination);

            const barCount = 28;
            elements.recordingWaveform.innerHTML = '';
            const bars = [];
            for (let i = 0; i < barCount; i += 1) {
                const bar = document.createElement('span');
                bar.className = 'wave-bar';
                bar.style.height = '15%';
                elements.recordingWaveform.appendChild(bar);
                bars.push(bar);
            }
            state.waveformBars = bars;
            state.waveformHeights = Array(barCount).fill(15);

            const dataArray = new Uint8Array(state.analyser.frequencyBinCount);
            const animate = () => {
                if (!state.analyser || !state.waveformBars || !state.waveformHeights) {
                    return;
                }
                state.analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for (let i = 0; i < dataArray.length; i += 1) {
                    sum += dataArray[i];
                }
                const average = sum / dataArray.length;
                const amplitude = Math.min((average / 255) * 200, 100);

                state.waveformHeights.shift();
                state.waveformHeights.push(amplitude);

                for (let i = 0; i < bars.length; i += 1) {
                    const height = Math.max(8, state.waveformHeights[i]);
                    bars[i].style.height = `${height}%`;
                }

                state.waveformFrameId = requestAnimationFrame(animate);
            };

            state.waveformFrameId = requestAnimationFrame(animate);
        }

        function cleanupWaveform() {
            if (state.waveformFrameId) {
                cancelAnimationFrame(state.waveformFrameId);
                state.waveformFrameId = null;
            }

            if (state.analyser) {
                state.analyser.disconnect();
                state.analyser = null;
            }

            if (state.audioContext && state.audioContext.state !== 'closed') {
                state.audioContext.close();
            }
            state.audioContext = null;

            if (elements.recordingWaveform) {
                elements.recordingWaveform.innerHTML = '';
            }
            state.waveformBars = null;
            state.waveformHeights = null;
        }

        function showRecordingIndicator(label) {
            const wrapper = elements.chatInput.parentElement;
            if (!wrapper) {
                return;
            }
            wrapper.classList.add('recording-active');
            elements.recordingLabel.textContent = label || 'Recording';
            if (!label) {
                elements.recordingTimer.textContent = '0:00';
            }
        }

        function hideRecordingIndicator() {
            const wrapper = elements.chatInput.parentElement;
            if (!wrapper) {
                return;
            }
            wrapper.classList.remove('recording-active');
        }

        function cleanupRecording() {
            if (state.mediaRecorder && state.mediaRecorder.state !== 'inactive') {
                state.mediaRecorder.stop();
            }

            if (state.recordingStream) {
                state.recordingStream.getTracks().forEach(track => track.stop());
                state.recordingStream = null;
            }

            state.mediaRecorder = null;
            state.recordingChunks = [];
            state.isRecording = false;
            elements.chatInput.disabled = false;
            if (state.recordingPlaceholder) {
                elements.chatInput.placeholder = state.recordingPlaceholder;
                state.recordingPlaceholder = '';
            }
            if (state.recordingTimerId) {
                clearInterval(state.recordingTimerId);
                state.recordingTimerId = null;
            }
            state.recordingStartedAt = 0;
            state.recordingDurationSec = 0;
            state.recordingCancelled = false;
            cleanupWaveform();
            hideRecordingIndicator();
            updateComposerMode();
        }

        async function startRecording() {
            if (state.isRecording || state.isSending) return;
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('Microphone is not available in this browser.');
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                state.recordingStream = stream;

                const mimeType = getRecordingMimeType();
                const recorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
                state.mediaRecorder = recorder;
                state.recordingChunks = [];
                state.isRecording = true;
                state.recordingCancelled = false;
                state.recordingPlaceholder = elements.chatInput.placeholder;
                elements.chatInput.placeholder = 'Recording voice note...';
                elements.chatInput.disabled = true;
                state.recordingStartedAt = Date.now();
                state.recordingDurationSec = 0;
                showRecordingIndicator();
                setupWaveform(stream);
                updateComposerMode();

                recorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        state.recordingChunks.push(event.data);
                    }
                };

                recorder.onstop = async () => {
                    const recordedChunks = state.recordingChunks.slice();
                    const durationSec = state.recordingStartedAt
                        ? Math.max(0, Math.floor((Date.now() - state.recordingStartedAt) / 1000))
                        : state.recordingDurationSec;
                    const wasCancelled = state.recordingCancelled;
                    cleanupRecording();

                    if (wasCancelled || recordedChunks.length === 0) {
                        return;
                    }

                    const blobType = mimeType || recordedChunks[0].type || 'audio/webm';
                    const audioBlob = new Blob(recordedChunks, { type: blobType });
                    await sendVoiceNote(audioBlob, durationSec);
                };

                if (state.recordingTimerId) {
                    clearInterval(state.recordingTimerId);
                }
                state.recordingTimerId = setInterval(() => {
                    if (!state.recordingStartedAt) {
                        return;
                    }
                    const elapsed = Date.now() - state.recordingStartedAt;
                    elements.recordingTimer.textContent = formatRecordingDuration(elapsed);
                    state.recordingDurationSec = Math.floor(elapsed / 1000);
                }, 250);

                recorder.start();
            } catch (error) {
                console.error('Error starting recording:', error);
                showError('Unable to access microphone.');
                cleanupRecording();
            }
        }

        function stopRecordingAndSend() {
            if (!state.isRecording || !state.mediaRecorder) {
                return;
            }
            if (state.mediaRecorder.state !== 'inactive') {
                state.mediaRecorder.stop();
            }
        }

        function cancelRecording() {
            if (!state.isRecording) {
                return;
            }
            state.recordingCancelled = true;
            if (state.mediaRecorder && state.mediaRecorder.state !== 'inactive') {
                state.mediaRecorder.stop();
                return;
            }
            cleanupRecording();
        }

        function updateOptimisticVoiceMessage(tempId, attachmentState, options = {}) {
            const messageNode = elements.chatMessages.querySelector(`[data-message-id="${tempId}"]`);
            if (!messageNode) {
                return;
            }
            const bubble = messageNode.querySelector('.message-bubble');
            if (!bubble) {
                return;
            }
            const newBubble = buildMessageBubble('', 'user', { audio: [attachmentState] }, options);
            bubble.replaceWith(newBubble);
        }

        function markVoiceNoteFailed(tempId) {
            updateOptimisticVoiceMessage(
                tempId,
                { failed: true },
                { onRetry: () => retryVoiceNote(tempId) }
            );
        }

        async function retryVoiceNote(tempId) {
            if (state.isSending) {
                return;
            }
            const pending = state.pendingVoiceNotes.get(tempId);
            if (!pending) {
                return;
            }
            updateOptimisticVoiceMessage(
                tempId,
                { loading: true },
                { onRetry: () => retryVoiceNote(tempId) }
            );
            state.isSending = true;
            elements.sendButton.disabled = true;
            try {
                const uploadId = generateUUID();
                const attachment = await uploadAudio(pending.blob, uploadId, pending.durationSec);
                const attachments = JSON.stringify({ audio: [attachment] });

                const response = await fetch(`${CONFIG.API_BASE}/chat/generate-response`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        agentId: state.agentId,
                        conversationId: state.conversationId,
                        message: '',
                        messageType: 1,
                        senderId: state.guestId,
                        senderRole: 1,
                        attachments: attachments
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to send voice note');
                }
            } catch (error) {
                console.error('Error retrying voice note:', error);
                markVoiceNoteFailed(tempId);
            } finally {
                state.isSending = false;
                elements.sendButton.disabled = false;
                updateComposerMode();
            }
        }

        async function uploadAudio(audioBlob, messageId, durationSec) {
            const fileType = audioBlob.type || 'audio/webm';
            const extension = fileType.split('/')[1] || 'webm';
            const audioFile = new File([audioBlob], `voice-${Date.now()}.${extension}`, {
                type: fileType
            });

            const formData = new FormData();
            formData.append('File', audioFile);
            formData.append('ConversationId', state.conversationId);
            formData.append('MessageId', messageId);
            if (typeof durationSec === 'number' && Number.isFinite(durationSec) && durationSec > 0) {
                formData.append('Duration', durationSec.toString());
            }

            const response = await fetch(`${CONFIG.API_BASE}/chat/upload-audio`, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error('Failed to upload audio');
            }

            const data = await response.json();
            if (!data || !data.success || !data.attachment) {
                throw new Error('Audio upload failed');
            }

            return data.attachment;
        }

        async function sendVoiceNote(audioBlob, durationSec) {
            if (state.isSending) return;

            state.isSending = true;
            elements.sendButton.disabled = true;
            setSendButtonMode('record');
            elements.sendButton.classList.remove('recording');

            const tempId = `temp-${Date.now()}`;
            const uploadId = generateUUID();
            const optimisticAttachments = { audio: [{ loading: true }] };
            appendMessage('', 'user', tempId, true, null, optimisticAttachments, {
                onRetry: () => retryVoiceNote(tempId)
            });
            const optimisticMsg = elements.chatMessages.querySelector(`[data-message-id="${tempId}"]`);
            if (optimisticMsg) {
                optimisticMsg.dataset.optimisticAudio = 'true';
            }

            hideRecordingIndicator();
            updateComposerMode();

            state.pendingVoiceNotes.set(tempId, { blob: audioBlob, durationSec });

            try {
                const attachment = await uploadAudio(audioBlob, uploadId, durationSec);
                const attachments = JSON.stringify({ audio: [attachment] });

                const responsePromise = fetch(`${CONFIG.API_BASE}/chat/generate-response`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        agentId: state.agentId,
                        conversationId: state.conversationId,
                        message: '',
                        messageType: 1,
                        senderId: state.guestId,
                        senderRole: 1,
                        attachments: attachments
                    })
                });

                const response = await responsePromise;
                if (!response.ok) {
                    throw new Error('Failed to send voice note');
                }
            } catch (error) {
                console.error('Error sending voice note:', error);
                markVoiceNoteFailed(tempId);
                showError('Failed to send voice note. Please try again.');
            } finally {
                state.isSending = false;
                elements.sendButton.disabled = false;
                elements.chatInput.focus();
                hideRecordingIndicator();
                updateComposerMode();
            }
        }

        function handleSendClick() {
            const message = elements.chatInput.value.trim();

            if (state.isRecording) {
                stopRecordingAndSend();
                return;
            }

            if (message) {
                sendMessage(message);
                return;
            }

            startRecording();
        }

        function handleInputKeyPress(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (elements.chatInput.value.trim()) {
                    handleSendClick();
                }
            }
        }

        function handleInputChange() {
            elements.chatInput.style.height = 'auto';
            elements.chatInput.style.height = elements.chatInput.scrollHeight + 'px';
            const hasText = elements.chatInput.value.trim().length > 0;
            elements.chatInput.parentElement.classList.toggle('has-text', hasText);
            updateComposerMode();
        }

        function handleNewConversationClick() {
            startNewConversation();
        }

        async function initialize() {
            try {
                if (CONFIG.WIDGET_ID === 'YOUR_WIDGET_ID_HERE' ||
                    CONFIG.SUPABASE_URL === 'YOUR_SUPABASE_URL') {
                    throw new Error('Please configure WIDGET_ID, SUPABASE_URL, and SUPABASE_ANON_KEY in the script');
                }

                initializeSupabase();
                await initiateConversation();
                await fetchHistoricalMessages();
                subscribeToMessages();
                subscribeToTypingIndicator();
                hideLoading();

                if (elements.chatMessages.children.length === 0) {
                    appendMessage(
                        "Hi, I'm your Wegovy AI assistant. How can I help you today?",
                        'assistant',
                        'welcome-' + Date.now(),
                        false,
                        null,
                        null
                    );
                }

                elements.sendButton.addEventListener('click', handleSendClick);
                elements.chatInput.addEventListener('keypress', handleInputKeyPress);
                elements.chatInput.addEventListener('input', handleInputChange);
                elements.newConversationBtn.addEventListener('click', handleNewConversationClick);
                elements.cancelRecordingBtn.addEventListener('click', cancelRecording);
                updateComposerMode();

                const setViewportHeightVar = () => {
                    document.documentElement.style.setProperty('--vvh', `${window.innerHeight}px`);
                };
                setViewportHeightVar();

                // Mobile keyboard handling
                if (/mobile|android|iphone|ipad|ipod/i.test(navigator.userAgent)) {
                    const inputArea = document.querySelector('.chat-input-area');
                    const hasVisualViewport = !!window.visualViewport;

                    if (hasVisualViewport) {
                        inputArea.classList.add('keyboard-aware');
                        const viewport = window.visualViewport;
                        let updateTimer = null;
                        let savedScrollY = null;

                        function updateInputPosition() {
                            const keyboardHeight = Math.max(
                                0,
                                window.innerHeight - viewport.height - viewport.offsetTop
                            );
                            document.documentElement.style.setProperty('--vvh', `${viewport.height}px`);
                            inputArea.style.bottom = `${keyboardHeight}px`;

                            if (keyboardHeight < 20 && savedScrollY !== null && document.activeElement !== elements.chatInput) {
                                window.scrollTo(0, savedScrollY);
                                savedScrollY = null;
                            }
                        }

                        function scheduleInputPositionUpdate() {
                            if (updateTimer) {
                                clearTimeout(updateTimer);
                            }
                            updateTimer = setTimeout(updateInputPosition, 50);
                        }

                        function clearPendingViewportUpdate() {
                            if (updateTimer) {
                                clearTimeout(updateTimer);
                                updateTimer = null;
                            }
                        }

                        elements.chatInput.addEventListener('focus', () => {
                            savedScrollY = window.scrollY;
                        });

                        elements.chatInput.addEventListener('blur', () => {
                            if (savedScrollY === null) {
                                return;
                            }
                            setTimeout(() => {
                                window.scrollTo(0, savedScrollY);
                                savedScrollY = null;
                            }, 0);
                        });

                        updateInputPosition();
                        viewport.addEventListener('resize', scheduleInputPositionUpdate);
                        viewport.addEventListener('scroll', scheduleInputPositionUpdate);
                        window.addEventListener('orientationchange', scheduleInputPositionUpdate);
                        window.addEventListener('pagehide', clearPendingViewportUpdate);
                        window.addEventListener('resize', setViewportHeightVar);
                        document.addEventListener('visibilitychange', () => {
                            if (document.hidden) {
                                clearPendingViewportUpdate();
                            }
                        });
                    } else {
                        // Fallback: minimal scroll into view on focus
                        elements.chatInput.addEventListener('focus', (e) => {
                            setTimeout(() => {
                                e.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }, 100);
                        });

                        // iOS-specific: Monitor window height changes
                        let lastWindowHeight = window.innerHeight;
                        window.addEventListener('resize', () => {
                            const currentHeight = window.innerHeight;
                            if (currentHeight < lastWindowHeight && document.activeElement === elements.chatInput) {
                                setTimeout(() => {
                                    elements.chatInput.scrollIntoView({
                                        behavior: 'smooth',
                                        block: 'center'
                                    });
                                }, 100);
                            }
                            lastWindowHeight = currentHeight;
                        });
                        window.addEventListener('resize', setViewportHeightVar);
                    }
                }

                elements.chatInput.focus();

            } catch (error) {
                console.error('Initialization error:', error);
                hideLoading();
                showError('Failed to initialize chat: ' + error.message);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }
    </script>
</body>
</html>
