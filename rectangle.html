<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wegovy Header Rectangle</title>
    <link rel="icon" href="favicon.ico">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@12.0.0/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>
    <link rel="stylesheet" href="rectangle.css">
</head>
<body>
    <div class="canvas">
        <div class="blank-rectangle" aria-label="Blank rectangle">
            <div class="top-controls">
                <button id="newConversationBtn" class="new-chat-btn" type="button" aria-label="Start a new chat" title="New conversation">
                    <span class="new-chat-label">New</span>
                    <span class="new-chat-plus" aria-hidden="true">+</span>
                </button>
            </div>
            <img src="wegovy_hd.png" alt="Wegovy" class="logo">
            <img src="top.png" alt="" class="top-band" aria-hidden="true">
            <div class="chat-shell">
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div class="loading-text">Connecting to Wegovy...</div>
                </div>

                <div class="chat-messages" id="chatMessages"></div>

                <div class="typing-indicator" id="typingIndicator">
                    <div class="typing-dots">
                        <span class="typing-dot"></span>
                        <span class="typing-dot"></span>
                        <span class="typing-dot"></span>
                    </div>
                </div>

                <div class="error-message" id="errorMessage"></div>

                <div class="chat-input-area">
                    <div class="input-wrapper">
                        <textarea
                            id="chatInput"
                            class="chat-input"
                            placeholder="Type your message..."
                            rows="1"
                        ></textarea>
                        <button id="sendButton" class="send-button" aria-label="Send message" title="Send">
                            <svg viewBox="0 0 24 24" aria-hidden="true">
                                <path d="M12 19V7M6 13l6-6 6 6"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const CONFIG = {
            API_BASE: 'https://mojeebapi.azurewebsites.net/api',
            WIDGET_ID: '58686180-0367-4fff-8d01-18ae10f7d70b',
            SUPABASE_URL: 'https://zssyyktaqahdfmehkdxn.supabase.co',
            SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpzc3l5a3RhcWFoZGZtZWhrZHhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM2MjUyNjYsImV4cCI6MjA2OTIwMTI2Nn0.6loB-m_y5To_zk3Inb7wvXSC00OOZ3FhMMTJMfdGlfg'
        };

        const state = {
            conversationId: null,
            agentId: null,
            guestId: null,
            supabaseClient: null,
            messageChannel: null,
            typingChannel: null,
            renderedMessageIds: new Set(),
            isSending: false
        };

        const elements = {
            chatMessages: document.getElementById('chatMessages'),
            chatInput: document.getElementById('chatInput'),
            sendButton: document.getElementById('sendButton'),
            typingIndicator: document.getElementById('typingIndicator'),
            errorMessage: document.getElementById('errorMessage'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            newConversationBtn: document.getElementById('newConversationBtn')
        };

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function getOrCreateGuestId() {
            let guestId = localStorage.getItem('mojeeb_guest_id');
            if (!guestId) {
                guestId = generateUUID();
                localStorage.setItem('mojeeb_guest_id', guestId);
            }
            return guestId;
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', {
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
        }

        function scrollToBottom() {
            setTimeout(() => {
                elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
            }, 100);
        }

        function showError(message) {
            elements.errorMessage.textContent = message;
            elements.errorMessage.classList.add('active');
            setTimeout(() => {
                elements.errorMessage.classList.remove('active');
            }, 5000);
        }

        function hideLoading() {
            elements.loadingOverlay.classList.add('hidden');
        }

        function sanitizeAndParse(text) {
            try {
                const parsed = marked.parse(text);
                return DOMPurify.sanitize(parsed);
            } catch (error) {
                console.error('Error parsing markdown:', error);
                return DOMPurify.sanitize(text.replace(/</g, '&lt;').replace(/>/g, '&gt;'));
            }
        }

        function appendMessage(content, type, messageId, isOptimistic = false, timestamp = null) {
            if (messageId && state.renderedMessageIds.has(messageId)) {
                return;
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.dataset.messageId = messageId || `temp-${Date.now()}`;

            if (isOptimistic) {
                messageDiv.dataset.optimistic = 'true';
            }

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'message-content';

            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';

            if (type === 'assistant') {
                bubble.innerHTML = sanitizeAndParse(content);
            } else {
                bubble.textContent = content;
            }

            const metaRow = document.createElement('div');
            metaRow.className = 'message-meta';

            const timeDiv = document.createElement('div');
            timeDiv.className = 'message-time';
            timeDiv.textContent = timestamp ? formatTime(timestamp) : formatTime(new Date());

            const copyButton = document.createElement('button');
            copyButton.className = 'copy-button';
            copyButton.type = 'button';
            copyButton.setAttribute('aria-label', 'Copy message');
            copyButton.title = 'Copy';
            copyButton.innerHTML = `
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M9 9h10v10H9zM5 5h10v10H5z"/>
                </svg>
            `;
            copyButton.dataset.icon = 'copy';

            const copyText = type === 'assistant'
                ? (() => {
                    const temp = document.createElement('div');
                    temp.innerHTML = sanitizeAndParse(content);
                    return temp.textContent || '';
                })()
                : content;

            copyButton.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(copyText);
                    copyButton.classList.add('copied');
                    copyButton.innerHTML = `
                        <svg viewBox="0 0 24 24" aria-hidden="true">
                            <path d="M5 13l4 4L19 7"/>
                        </svg>
                    `;
                    copyButton.dataset.icon = 'check';
                    setTimeout(() => {
                        copyButton.classList.remove('copied');
                        copyButton.innerHTML = `
                            <svg viewBox="0 0 24 24" aria-hidden="true">
                                <path d="M9 9h10v10H9zM5 5h10v10H5z"/>
                            </svg>
                        `;
                        copyButton.dataset.icon = 'copy';
                    }, 1200);
                } catch (error) {
                    console.error('Copy failed:', error);
                }
            });

            metaRow.appendChild(timeDiv);
            metaRow.appendChild(copyButton);

            contentWrapper.appendChild(bubble);
            contentWrapper.appendChild(metaRow);

            messageDiv.appendChild(contentWrapper);
            elements.chatMessages.appendChild(messageDiv);
            elements.chatMessages.appendChild(elements.typingIndicator);

            if (messageId) {
                state.renderedMessageIds.add(messageId);
            }

            scrollToBottom();
            updateNewChatVisibility();
        }

        function replaceOptimisticMessage(serverMessage) {
            const optimisticMessages = elements.chatMessages.querySelectorAll('[data-optimistic="true"]');

            for (const msg of optimisticMessages) {
                const bubble = msg.querySelector('.message-bubble');
                if (bubble && bubble.textContent === serverMessage.message) {
                    msg.remove();
                    return true;
                }
            }

            return false;
        }

        function showTypingIndicator() {
            elements.chatMessages.appendChild(elements.typingIndicator);
            elements.typingIndicator.classList.add('active');
            scrollToBottom();
        }

        function hideTypingIndicator() {
            elements.typingIndicator.classList.remove('active');
        }

        function updateNewChatVisibility() {
            const hasMessages = elements.chatMessages.children.length > 0;
            elements.newConversationBtn.classList.toggle('visible', hasMessages);
        }

        async function startNewConversation() {
            try {
                elements.newConversationBtn.disabled = true;

                localStorage.removeItem('mojeeb_conversation_id');
                state.conversationId = null;

                state.renderedMessageIds.clear();

                const typingIndicator = elements.typingIndicator;
                elements.chatMessages.innerHTML = '';
                hideTypingIndicator();
                updateNewChatVisibility();

                if (state.typingChannel) {
                    await state.typingChannel.unsubscribe();
                    state.typingChannel = null;
                }

                if (state.messageChannel) {
                    await state.messageChannel.unsubscribe();
                    state.messageChannel = null;
                }

                await initiateConversation();
                subscribeToMessages();
                subscribeToTypingIndicator();

                appendMessage(
                    "Hi, I'm your Wegovy AI assistant. How can I help you today?",
                    'assistant',
                    'welcome-' + Date.now(),
                    false
                );

                elements.newConversationBtn.disabled = false;
                elements.chatInput.focus();
            } catch (error) {
                console.error('Error starting new conversation:', error);
                showError('Failed to start new conversation. Please try again.');
                elements.newConversationBtn.disabled = false;
            }
        }

        async function initiateConversation() {
            const guestId = getOrCreateGuestId();

            const savedConversationId = localStorage.getItem('mojeeb_conversation_id');
            const savedAgentId = localStorage.getItem('mojeeb_agent_id');

            if (savedConversationId && savedAgentId) {
                state.conversationId = savedConversationId;
                state.agentId = savedAgentId;
                state.guestId = guestId;
                return { conversationId: savedConversationId, agentId: savedAgentId };
            }

            const response = await fetch(`${CONFIG.API_BASE}/conversations/initiate-widget-conversation`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    widget_id: CONFIG.WIDGET_ID,
                    customer_name: 'Guest User',
                    customer_id: guestId,
                    customer_metadata: {
                        currentUrl: window.location.href,
                        deviceType: /mobile/i.test(navigator.userAgent) ? 'mobile' : 'desktop',
                        language: navigator.language,
                        referrer: document.referrer || 'direct'
                    }
                })
            });

            if (!response.ok) {
                throw new Error('Failed to create conversation');
            }

            const data = await response.json();

            state.conversationId = data.id;
            state.agentId = data.agent_id;
            state.guestId = guestId;

            localStorage.setItem('mojeeb_conversation_id', data.id);
            localStorage.setItem('mojeeb_agent_id', data.agent_id);

            return data;
        }

        async function sendMessage(message) {
            if (state.isSending || !message.trim()) return;

            state.isSending = true;
            elements.sendButton.disabled = true;

            try {
                const tempId = `temp-${Date.now()}`;
                appendMessage(message, 'user', tempId, true);

                elements.chatInput.value = '';
                elements.chatInput.style.height = 'auto';

                const response = await fetch(`${CONFIG.API_BASE}/chat/generate-response`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        agentId: state.agentId,
                        conversationId: state.conversationId,
                        message: message,
                        messageType: 0,
                        senderId: state.guestId,
                        senderRole: 1
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to send message');
                }
            } catch (error) {
                console.error('Error sending message:', error);
                showError('Failed to send message. Please try again.');

                const optimisticMsg = elements.chatMessages.querySelector(`[data-message-id="${tempId}"]`);
                if (optimisticMsg) {
                    optimisticMsg.remove();
                }
            } finally {
                state.isSending = false;
                elements.sendButton.disabled = false;
                elements.chatInput.focus();
            }
        }

        function initializeSupabase() {
            if (!window.supabase) {
                throw new Error('Supabase client not loaded');
            }

            state.supabaseClient = window.supabase.createClient(
                CONFIG.SUPABASE_URL,
                CONFIG.SUPABASE_ANON_KEY
            );
        }

        function subscribeToMessages() {
            if (!state.supabaseClient || !state.conversationId) return;

            state.messageChannel = state.supabaseClient
                .channel('public:chats')
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'chats',
                    filter: `conversation_id=eq.${state.conversationId}`
                }, (payload) => {
                    const message = payload.new;

                    if (replaceOptimisticMessage(message)) {
                        appendMessage(
                            message.message,
                            message.sender_id === state.guestId ? 'user' : 'assistant',
                            message.id,
                            false,
                            message.created_at
                        );
                    } else {
                        if (message.sender_id !== state.guestId) {
                            hideTypingIndicator();
                            appendMessage(
                                message.message,
                                'assistant',
                                message.id,
                                false,
                                message.created_at
                            );
                        }
                    }
                })
                .subscribe();
        }

        function subscribeToTypingIndicator() {
            if (!state.supabaseClient || !state.conversationId) return;

            state.typingChannel = state.supabaseClient
                .channel(`chat:${state.conversationId}`)
                .on('broadcast', { event: 'typing' }, (payload) => {
                    if (payload.payload?.is_typing) {
                        showTypingIndicator();
                    } else {
                        hideTypingIndicator();
                    }
                })
                .subscribe();
        }

        async function fetchHistoricalMessages() {
            if (!state.supabaseClient || !state.conversationId) return;

            try {
                const { data, error } = await state.supabaseClient
                    .from('chats')
                    .select('*')
                    .eq('conversation_id', state.conversationId)
                    .order('created_at', { ascending: true });

                if (error) throw error;

                if (data && data.length > 0) {
                    data.forEach(message => {
                        appendMessage(
                            message.message,
                            message.sender_id === state.guestId ? 'user' : 'assistant',
                            message.id,
                            false,
                            message.created_at
                        );
                    });
                } else {
                    updateNewChatVisibility();
                }
            } catch (error) {
                console.error('Error fetching messages:', error);
            }
        }

        function handleSendClick() {
            const message = elements.chatInput.value.trim();
            if (message) {
                sendMessage(message);
            }
        }

        function handleInputKeyPress(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSendClick();
            }
        }

        function handleInputChange() {
            elements.chatInput.style.height = 'auto';
            elements.chatInput.style.height = elements.chatInput.scrollHeight + 'px';
            const hasText = elements.chatInput.value.trim().length > 0;
            elements.chatInput.parentElement.classList.toggle('has-text', hasText);
        }

        function handleNewConversationClick() {
            startNewConversation();
        }

        async function initialize() {
            try {
                if (CONFIG.WIDGET_ID === 'YOUR_WIDGET_ID_HERE' ||
                    CONFIG.SUPABASE_URL === 'YOUR_SUPABASE_URL') {
                    throw new Error('Please configure WIDGET_ID, SUPABASE_URL, and SUPABASE_ANON_KEY in the script');
                }

                initializeSupabase();
                await initiateConversation();
                await fetchHistoricalMessages();
                subscribeToMessages();
                subscribeToTypingIndicator();
                hideLoading();

                if (elements.chatMessages.children.length === 0) {
                    appendMessage(
                        "Hi, I'm your Wegovy AI assistant. How can I help you today?",
                        'assistant',
                        'welcome-' + Date.now(),
                        false
                    );
                }

                elements.sendButton.addEventListener('click', handleSendClick);
                elements.chatInput.addEventListener('keypress', handleInputKeyPress);
                elements.chatInput.addEventListener('input', handleInputChange);
                elements.newConversationBtn.addEventListener('click', handleNewConversationClick);
                elements.chatInput.focus();

            } catch (error) {
                console.error('Initialization error:', error);
                hideLoading();
                showError('Failed to initialize chat: ' + error.message);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initialize);
        } else {
            initialize();
        }
    </script>
</body>
</html>
